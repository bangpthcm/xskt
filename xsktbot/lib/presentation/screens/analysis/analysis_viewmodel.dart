// lib/presentation/screens/analysis/analysis_viewmodel.dart
import 'package:flutter/material.dart';
import '../../../data/models/gan_pair_info.dart';
import '../../../data/models/cycle_analysis_result.dart';
import '../../../data/models/lottery_result.dart';
import '../../../data/models/app_config.dart';
import '../../../data/services/google_sheets_service.dart';
import '../../../data/services/analysis_service.dart';
import '../../../data/services/storage_service.dart';
import '../../../data/services/telegram_service.dart';
import '../../../data/services/betting_table_service.dart';
import '../../../core/utils/date_utils.dart' as date_utils;

class AnalysisViewModel extends ChangeNotifier {
  final GoogleSheetsService _sheetsService;
  final AnalysisService _analysisService;
  final StorageService _storageService;
  final TelegramService _telegramService;
  final BettingTableService _bettingService;

  AnalysisViewModel({
    required GoogleSheetsService sheetsService,
    required AnalysisService analysisService,
    required StorageService storageService,
    required TelegramService telegramService,
    required BettingTableService bettingService,
  })  : _sheetsService = sheetsService,
        _analysisService = analysisService,
        _storageService = storageService,
        _telegramService = telegramService,
        _bettingService = bettingService;

  bool _isLoading = false;
  String? _errorMessage;
  GanPairInfo? _ganPairInfo;
  CycleAnalysisResult? _cycleResult;
  String _selectedMien = 'T·∫•t c·∫£';
  List<LotteryResult> _allResults = [];

  bool get isLoading => _isLoading;
  String? get errorMessage => _errorMessage;
  GanPairInfo? get ganPairInfo => _ganPairInfo;
  CycleAnalysisResult? get cycleResult => _cycleResult;
  String get selectedMien => _selectedMien;

  void setSelectedMien(String mien) {
    _selectedMien = mien;
    notifyListeners();
  }

  Future<void> loadAnalysis({bool useCache = true}) async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      final allValues = await _sheetsService.getAllValues('KQXS');
      
      if (allValues.length < 2) {
        throw Exception('Kh√¥ng c√≥ d·ªØ li·ªáu trong sheet');
      }

      _allResults = [];
      for (int i = 1; i < allValues.length; i++) {
        try {
          _allResults.add(LotteryResult.fromSheetRow(allValues[i]));
        } catch (e) {
          // Skip invalid rows
        }
      }

      _ganPairInfo = await _analysisService.findGanPairsMienBac(_allResults);

      if (_selectedMien == 'T·∫•t c·∫£') {
        _cycleResult = await _analysisService.analyzeCycle(_allResults);
      } else {
        final filteredResults = _allResults
            .where((r) => r.mien == _selectedMien)
            .toList();
        _cycleResult = await _analysisService.analyzeCycle(filteredResults);
      }

      _isLoading = false;
      notifyListeners();
    } catch (e) {
      _errorMessage = 'L·ªói ph√¢n t√≠ch: $e';
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> createCycleBettingTable(AppConfig config) async {
    if (_cycleResult == null) {
      _errorMessage = 'Ch∆∞a c√≥ d·ªØ li·ªáu chu k·ª≥';
      notifyListeners();
      return;
    }

    // ‚úÖ B·ªé ƒëi·ªÅu ki·ªán ki·ªÉm tra maxGanDays > 3
    
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      final latestDate = _allResults
          .map((r) => date_utils.DateUtils.parseDate(r.ngay))
          .where((d) => d != null)
          .reduce((a, b) => a!.isAfter(b!) ? a : b);

      final startDate = latestDate!.add(const Duration(days: 1));
      var endDate = _cycleResult!.lastSeenDate.add(const Duration(days: 8));
      
      double budgetMax = config.budget.budgetMax;
      
      if (date_utils.DateUtils.getWeekday(endDate) == 1) {
        endDate = endDate.add(const Duration(days: 1));
        budgetMax += 200000.0;
      }

      final newTable = await _bettingService.generateCycleTable(
        cycleResult: _cycleResult!,
        startDate: startDate,
        endDate: endDate,
        startMienIndex: 0,
        budgetMin: config.budget.budgetMin,
        budgetMax: budgetMax,
      );

      await _saveCycleTableToSheet(newTable);

      _isLoading = false;
      notifyListeners();
    } catch (e) {
      _errorMessage = 'L·ªói t·∫°o b·∫£ng: $e';
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> createXienBettingTable() async {
    if (_ganPairInfo == null) {
      _errorMessage = 'Ch∆∞a c√≥ d·ªØ li·ªáu c·∫∑p s·ªë gan';
      notifyListeners();
      return;
    }

    // ‚úÖ B·ªé ƒëi·ªÅu ki·ªán ki·ªÉm tra daysGan > 155

    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      final latestDate = _allResults
          .map((r) => date_utils.DateUtils.parseDate(r.ngay))
          .where((d) => d != null)
          .reduce((a, b) => a!.isAfter(b!) ? a : b);

      final startDate = latestDate!.add(const Duration(days: 1));
      
      final newTable = await _bettingService.generateXienTable(
        ganInfo: _ganPairInfo!,
        startDate: startDate,
      );

      await _saveXienTableToSheet(newTable);

      _isLoading = false;
      notifyListeners();
    } catch (e) {
      _errorMessage = 'L·ªói t·∫°o b·∫£ng: $e';
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> _saveCycleTableToSheet(List<dynamic> table) async {
    print('üìù Saving cycle table to sheet...'); // ‚úÖ ADD
    print('üìä Table rows: ${table.length}'); // ‚úÖ ADD
    
    await _sheetsService.clearSheet('xsktBot1');

    await _sheetsService.updateRange(
      'xsktBot1',
      'A1:D1',
      [
        [
          _cycleResult!.maxGanDays.toString(),
          date_utils.DateUtils.formatDate(_cycleResult!.lastSeenDate),
          _cycleResult!.ganNumbersDisplay,
          _cycleResult!.targetNumber,
        ]
      ],
    );

    await _sheetsService.updateRange(
      'xsktBot1',
      'A3:J3',
      [
        ['STT', 'Ng√†y', 'Mi·ªÅn', 'S·ªë', 'S·ªë l√¥', 'C∆∞·ª£c/s·ªë', 'C∆∞·ª£c/mi·ªÅn', 'T·ªïng ti·ªÅn', 'L·ªùi (1 s·ªë)', 'L·ªùi (2 s·ªë)']
      ],
    );

    final dataRows = table.map((row) => row.toSheetRow()).toList().cast<List<String>>();
    await _sheetsService.updateRange('xsktBot1', 'A4', dataRows);
    
    print('‚úÖ Cycle table saved successfully!'); // ‚úÖ ADD
  }

  Future<void> _saveXienTableToSheet(List<dynamic> table) async {
    print('üìù Saving xien table to sheet...'); // ‚úÖ ADD
    print('üìä Table rows: ${table.length}'); // ‚úÖ ADD
    
    await _sheetsService.clearSheet('xienBot');

    await _sheetsService.updateRange(
      'xienBot',
      'A1:D1',
      [
        [
          _ganPairInfo!.daysGan.toString(),
          date_utils.DateUtils.formatDate(_ganPairInfo!.lastSeen),
          _ganPairInfo!.pairsDisplay,
          table.first.so,
        ]
      ],
    );

    await _sheetsService.updateRange(
      'xienBot',
      'A3:G3',
      [
        ['STT', 'Ng√†y', 'Mi·ªÅn', 'S·ªë', 'C∆∞·ª£c/mi·ªÅn', 'T·ªïng ti·ªÅn', 'L·ªùi']
      ],
    );

    final dataRows = table.map((row) => row.toSheetRow()).toList().cast<List<String>>();
    await _sheetsService.updateRange('xienBot', 'A4', dataRows);
    
    print('‚úÖ Xien table saved successfully!'); // ‚úÖ ADD
  }

  Future<void> sendCycleAnalysisToTelegram() async {
    if (_cycleResult == null) {
      _errorMessage = 'Ch∆∞a c√≥ d·ªØ li·ªáu chu k·ª≥';
      notifyListeners();
      return;
    }

    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      final buffer = StringBuffer();
      buffer.writeln('<b>üìä PH√ÇN T√çCH CHU K·ª≤ 00-99 üìä</b>\n');
      buffer.writeln('<b>Filter:</b> $_selectedMien\n');
      buffer.writeln('<b>S·ªë ng√†y gan:</b> ${_cycleResult!.maxGanDays} ng√†y');
      buffer.writeln('<b>L·∫ßn cu·ªëi v·ªÅ:</b> ${date_utils.DateUtils.formatDate(_cycleResult!.lastSeenDate)}');
      buffer.writeln('<b>S·ªë m·ª•c ti√™u:</b> ${_cycleResult!.targetNumber}\n');
      
      buffer.writeln('<b>Nh√≥m s·ªë gan nh·∫•t:</b>');
      buffer.writeln(_cycleResult!.ganNumbersDisplay);
      buffer.writeln();
      
      buffer.writeln('<b>Ph√¢n b·ªï theo mi·ªÅn:</b>');
      for (final mien in ['Nam', 'Trung', 'B·∫Øc']) {
        if (_cycleResult!.mienGroups.containsKey(mien)) {
          buffer.writeln('- Mi·ªÅn $mien: ${_cycleResult!.mienGroups[mien]!.join(", ")}');
        }
      }

      await _telegramService.sendMessage(buffer.toString());
      
      _isLoading = false;
      notifyListeners();
    } catch (e) {
      _errorMessage = 'L·ªói g·ª≠i Telegram: $e';
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> sendGanPairAnalysisToTelegram() async {
    if (_ganPairInfo == null) {
      _errorMessage = 'Ch∆∞a c√≥ d·ªØ li·ªáu c·∫∑p s·ªë gan';
      notifyListeners();
      return;
    }

    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      final buffer = StringBuffer();
      buffer.writeln('<b>üìà C·∫∂P S·ªê GAN MI·ªÄN B·∫ÆC üìà</b>\n');
      buffer.writeln('ƒê√¢y l√† 2 c·∫∑p s·ªë ƒë√£ l√¢u nh·∫•t ch∆∞a xu·∫•t hi·ªán c√πng nhau:\n');
      
      for (int i = 0; i < _ganPairInfo!.pairs.length && i < 2; i++) {
        final pairWithDays = _ganPairInfo!.pairs[i];
        buffer.writeln('${i + 1}. C·∫∑p <b>${pairWithDays.display}</b> (${pairWithDays.daysGan} ng√†y)');
      }
      
      buffer.writeln('\n<b>C·∫∑p gan nh·∫•t:</b> ${_ganPairInfo!.pairs[0].display}');
      buffer.writeln('<b>S·ªë ng√†y gan:</b> ${_ganPairInfo!.daysGan} ng√†y');
      buffer.writeln('<b>L·∫ßn cu·ªëi v·ªÅ:</b> ${date_utils.DateUtils.formatDate(_ganPairInfo!.lastSeen)}');

      await _telegramService.sendMessage(buffer.toString());
      
      _isLoading = false;
      notifyListeners();
    } catch (e) {
      _errorMessage = 'L·ªói g·ª≠i Telegram: $e';
      _isLoading = false;
      notifyListeners();
    }
  }

  // ‚úÖ TH√äM METHOD N√ÄY
  void clearError() {
    _errorMessage = null;
    notifyListeners();
  }
}